So okt 25 18:25:49 CEST 2014
pocitanie relevant_subforests a full_decomposition funguje ako je napisane nizsie. implementoval som to pomocou unordered_map (== hash_map), s hashovanim cez node_id.


Å t okt 23 10:29:39 CEST 2014
pocitanie set-of-relevant-subforests by malo fungovat tak, o=otec, i je najlavejsi syn, j su zvysny (i!=j)
	F(o, left_path) = F(i, left_path) + Tj.size() + 1
	F(o, left_path_set) = F(i, i_left_path) + F(j, left_path_set)
teda to vyzera tak, ze pre jednu konkretnu cestu, relevant-subforests vypocitam tak, ze zmazem koren (== +1), zmazem vsetky podstromy okrem laveho (== +Tj.size()) a potom vyratam z podstromu zvysok (== F(i, left_path))
pre mnozinu lavych ciest, co sa pouziva uz v algoritme je to tak, ze okrem vypocitania predchadzajuceho problemu este aj na zvysnych podstromoch volam rovnaky algoritmus.
.. => malo by to ist lahko vyratat z podstromov (ako samotnu velkost). 


Po okt 20 20:41:21 CEST 2014
pocitanie full-decomposition (A) sa da zo synov:
vzdy si budem pocitat pocet lavych a pravych dekompozicii (Aleft, Aright). samotny korenovy vrchol nezapocitavam ani do jednej z nich (zatial)
pre otca o a synov i,j, resp. k (0<=i<j<=n; 0<=k<=n) bude platit:
	A[o] = sum(Aleft[i] * Aright[j]) + sum(A[k]) + 1
toto by malo platit, zo stromu i mozem vyberat iba lave dekompozicie, a z j iba prave. potom treba pripocitat este iba samotne podstromy k a jednicku za samotny vrchol o.
.. pre Aleft/Aright bude platit:
	Aleft[o] = sum(Aleft[k])
	Aright[o] = sum(Aright[k])


Mon Oct 13 10:59:31 CEST 2014
pozn. k RTEDu, tie polia Hv,Lv,Rv su iba pocty podproblemov ktore budem musiet pocitat, ak sa vydam strategiou H/L/R. 
{H,L,R}w - neviem co to je.
